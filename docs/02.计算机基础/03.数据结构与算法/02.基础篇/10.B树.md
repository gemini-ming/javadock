---
title: B树
date: 2023-11-02 15:44:54
permalink: /pages/970216/
author: 
  name: 泪伤荡
  link: https://github.com/gemini-ming
---
# B树

## 初识 B树

B树 是一种平衡的**多路**搜索树，多用于文件系统、数据库的实现

*特点*

- 1 个节点可以存储**超过** 2 个元素、可以拥有**超过** 2 个子节点
- 拥有二叉搜索树的一些性质（左右大小关系）
- 平衡，每个节点的所有子树高度一致
- 比较矮

## m 阶 B树 的性质（m>=2)

> m 阶的意思：就是意味着这棵 B树 最多有 m 个子节点，每个节点最多存储 m-1 个元素。

*1、假设一个节点存储的元素个数为 x*

- 根节点: `1 <= x <= m - 1`
- 非根节点: `┌ m/2 ┐ - 1 < x < m - 1`
- **`┌ m/2 ┐` -- 是向上取整的意思**

*2、如果有子节点，子节点个数为 y = x + 1*

- 根节点: `2 <= y <= m`
- 非根节点: `┌ m/2 ┐ <= y <= m`
  - 比如 m = 3，`2 <= y <= 3`，因此可以称为 (2,3) 树、2-3 树
  - 比如 m = 4，`2 <= y <= 4`，因此可以称为 (2,4) 树、2-3-4 树
  - 比如 m = 5，`3 <= y <= 5`，因此可以称为 (3,5) 树
  - 比如 m = 6，`3 <= y <= 6`，因此可以称为 (3,6) 树
  - 比如 m = 7，`4 <= y <= 7`，因此可以称为 (4,7) 树

*4 阶 B树 如下图所示*

![image](https://cmty256.github.io/imgs-blog/basics/image.bdx7egi3h0o.webp)

*数据库实现中一般用【几阶B树】？*

一般是 200 ~ 300

*思考：如果 m = 2，那【B树】是什么样子的？*

## B树 VS 二叉搜索树

1. B树 和 二又搜索树，在逻辑上是等价的（只不过是【B树】一个节点融合了多个元素）

2. 多代节点合并，可以获得一个超级节点
   - 2 代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树）
   - 3 代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树）
   - n 代合并的超级节点，最多拥有 (2^n) 个子节点（至少是 2^n 阶B树）
3. m阶B树，最多需要 log2(m) 代合并



*二叉搜索树*

![image](https://cmty256.github.io/imgs-blog/basics/image.14ire6wq0q4g.webp)

*B树*

![image](https://cmty256.github.io/imgs-blog/basics/image.2qhwhkleth00.webp)

## 搜索

1. 先在节点内部从小到大开始搜索
2. 元素如果命中，搜索结束
3. 如果未命中，再去对应的子节点中搜索元素，重复步骤 1

## 添加

### 上溢现象

当在【B树】中添加元素时，可能会导致上溢（Overflow）情况，即**节点中的关键字个数超过了节点的容量**。

### 上溢的解决

1. 上溢节点的元素个数必然等于 m。

2. 假设上溢节点最中间元素的**位置**为 k
   - 将 k 位置的元素向上与父节点合并
   - 将 [0, k-1] 和 [k+1, m-1] 位置的元素分裂成 2 个子节点
     - 这 2 个子节点的元素个数，必然都不会低于最低限制 (`┌ m/2 ┐ - 1`)

3. 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决
   - 最极端的情况，有可能一直分裂到根节点

*具体如下图所示*

![image](https://cmty256.github.io/imgs-blog/images/image.5ktcbq5cgxo0.webp)

### 插入元素分析

![image](https://cmty256.github.io/imgs-blog/images/image.3tawr0tpjy40.webp)

## 删除

### 删除 - 叶子节点

假如需要删除的元素在叶子节点中，那么直接删除即可。

### 删除 - 非叶子节点

假如需要删除的元素在非叶子节点中

1. 先找到前驱或后继元素，覆盖所需删除元素的值

2. 再把前驱或后继元素删除

*如下图示：*

![image](https://cmty256.github.io/imgs-blog/images/image.74119nw0ac80.webp)

- **非叶子节点**的前驱或后继元素，必定在**叶子节点**中
- 所以这里的删除前驱或后继元素，就是最开始提到的情况: 删除的元素在叶子节点中

### 下溢现象

- 叶子节点被删掉一个元素后，元素个数可能会低于最低限制(`┌ m/2 ┐ - 1`)
- 这种现象称为：**下溢**（underflow）

### 下溢的解决

1. 下溢节点的元素数量必然等于 `┌ m/2 ┐ - 2`

2. 如果下溢节点临近的兄弟节点，有*至少* `┌ m/2 ┐` 个元素，可以向其**借**一个元素

   - 将父节点的元素 b 插入到下溢节点的 0 位置(最小位置)
   - 用兄弟节点的元素 a (最大的元素) 替代父节点的元素 b 
   - 这种操作其实就是：**旋转**

   ![image-20231103180147476](https://cmty256.github.io/imgs-blog/basics/image-20231103180147476.h3t6ljlt7z4.webp)

3. 如果下溢节点临近的兄弟节点，*只有* `┌ m/2 ┐ - 1` 个元素

   - 将父节点的元素 b 挪下来跟左右子节点进行**合并**
   - 合并后的节点元素个数等于 `┌ m/2 ┐ + ┌ m/2 ┐ - 2`，不超过 `m - 1`

   - 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播，最坏的情况是一直到根节点下溢 

![image](https://cmty256.github.io/imgs-blog/images/image.4pan5l0305u0.webp)

*根节点下溢怎么办？*

这个时候根节点必然是：

- 根节点所有东西跟它底下子节点合并成新的根节点。
- 此时树会变矮，少掉一层

## 4阶B树

**4阶B树**的性质

1. 所有节点能**存储的元素个数** x: *1 <= x <= 3*
2. 所有非叶子节点的**子节点个数** y: *2 <= y <= 4*

*思考*

从 1 添加到 22，从 1 删除到 22 的情况。

可通过该网站查看流程细节：[B-Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/BTree.html)
