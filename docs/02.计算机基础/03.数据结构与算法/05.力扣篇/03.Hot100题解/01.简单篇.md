---
title: ç®€å•ç¯‡
date: 2023-05-12 11:17:38
permalink: /computer/data/9b4014/
author: 
  name: æ³ªä¼¤è¡
  link: https://github.com/gemini-ming
---
# ç®€å•ç¯‡

## [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)

### é¢˜ç›®æè¿°

![image](https://cmty256.github.io/imgs-blog/basics/image.4d4ob21ocnq0.webp)



### æ–¹æ³•ä¸€ï¼šæš´åŠ›æšä¸¾

```java
    /**
     * 1ã€æš´åŠ›æšä¸¾ -- 49ms(40.58%), 42.8MB(9.48%)
     */
    class Solution {
        public int[] twoSum(int[] nums, int target) {
            int[] result = new int[2];
            for (int i = 0; i < nums.length; i++) {
                for (int j = i + 1; j < nums.length; j++) {
                    if (nums[i] + nums[j] == target) {
                        // return new int[]{i, j};
                        result[0] = i;
                        result[1] = j;
                    }
                }
            }
            return result;
        }
    }
```



### æ–¹æ³•äºŒï¼šå“ˆå¸Œè¡¨æ˜ å°„

```java
    /**
     * 2ã€å“ˆå¸Œè¡¨æ˜ å°„ -- 1ms(99.52%), 42.9MB(5.7%)
     */
   class Solution2 {
        public int[] twoSum(int[] nums, int target) {
            // åˆ›å»ºä¸€ä¸ªHashMap
            Map<Integer, Integer> map = new HashMap<>();
            // éå†æ•°ç»„
            for (int i = 0; i < nums.length; i++) {
                // å¦‚æœmapä¸­åŒ…å«target - nums[i]ï¼Œåˆ™è¿”å›mapä¸­target - nums[i]å¯¹åº”çš„å€¼å’Œi
                if (map.containsKey(target - nums[i])) {
                    return new int[]{map.get(target - nums[i]), i};
                }
                // å°†nums[i]å’Œiæ”¾å…¥mapä¸­
                map.put(nums[i], i);
            }
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¸¤ä¸ªæ•°çš„å’Œç­‰äºtargetï¼ŒæŠ›å‡ºå¼‚å¸¸
            throw new IllegalArgumentException("No two sum solution");
        }
    }
```



## [20. æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses/)

![image-20230415110215814](https://cmty256.github.io/imgs-blog/basics/image-20230415110215814.2fzlqb8oat0k.webp)

```java
class Solution {
    public boolean isValid(String s) {
        // ç”¨æ•°ç»„æ¥åšï¼Œæ€æƒ³å’Œç”¨æ ˆåšä¸€æ ·ï¼Œä½†æ•ˆç‡é«˜
        char[] c = new char[s.length()];
        // æ ‡è®°æ•°ç»„ c ä¸­ä¸‹ä¸€ä¸ªå…ƒç´ åº”è¯¥æ’å…¥çš„ä½ç½®
        int index = 0; 
        // éå†å­—ç¬¦ä¸² s ä¸­çš„æ¯ä¸ªå­—ç¬¦
        for(int i = 0; i < s.length(); i++) { 
            // å–å‡ºå­—ç¬¦ä¸² s ä¸­ç¬¬ i ä¸ªå­—ç¬¦
            char c1 = s.charAt(i); 
            
            if(c1 == '(') 
                // å¦‚æœè¯¥å­—ç¬¦æ˜¯å·¦æ‹¬å· '(', åˆ™å°†ç›¸åº”çš„å³æ‹¬å· ')' å­˜å…¥æ•°ç»„ c ä¸­
                c[index++] = ')';
            else if(c1 == '[') 
                // å¦‚æœè¯¥å­—ç¬¦æ˜¯å·¦æ‹¬å· '[', åˆ™å°†ç›¸åº”çš„å³æ‹¬å· ']' å­˜å…¥æ•°ç»„ c ä¸­
                c[index++] = ']';
            else if(c1 == '{') 
                // å¦‚æœè¯¥å­—ç¬¦æ˜¯å·¦æ‹¬å· '{', åˆ™å°†ç›¸åº”çš„å³æ‹¬å· '}' å­˜å…¥æ•°ç»„ c ä¸­
                c[index++] = '}';
            else if(index == 0 || c[--index] != c1) 
                // å¦‚æœè¯¥å­—ç¬¦ä¸æ˜¯å·¦æ‹¬å·ï¼Œä¸”è¯¥å­—ç¬¦ä¸æ•°ç»„ c ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¸åŒ¹é…ï¼Œæˆ–è€…æ•°ç»„ c ä¸­æ²¡æœ‰å…ƒç´ ï¼Œåˆ™è¿”å› false
                return false;
        }
        // å¦‚æœæ•°ç»„ c ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½è¢«åŒ¹é…äº†ï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
        return index == 0; 
    }
}
```

```java
        int n = s.length();
        if(n % 2 == 1){
            return false;
        }
        int length = n / 2;
        for( int i = 0;i < length;i++){
            s = s.replace("()","");
            s = s.replace("[]","");
            s = s.replace("{}","");
        }
        return s.length() == 0;
```
```java
        if(s.length() % 2 == 1){
            return false;
        }
        HashMap<Character, Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');

        char[] arr = new char[s.length()];
        int idx = 0;
        	for (char c: s.toCharArray()) {
        	if (map.containsKey(c)) {
        		arr[idx++] = c;
        		continue;
        	}
        	if (idx == 0) {
        		return false;
        	}
        	if (map.get(arr[idx-1]) == c) {
        		idx--;
        	} else {
        		return false;
        	}
        }
        return idx == 0;
```

## [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)

### é¢˜ç›®æè¿°

![image-20230415110510720](https://cmty256.github.io/imgs-blog/basics/image-20230415110510720.5xcssgbjsxs0.webp)



### æ–¹æ³•ä¸€ï¼šè¿­ä»£

```java
    /**
     * 1ã€è¿­ä»£ï¼ˆåŒæŒ‡é’ˆï¼‰ -- 0ms(100.00%), 41.5MB(5.14%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(m + n), å…¶ä¸­ m å’Œ n åˆ†åˆ«ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    class Solution {
        public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
            ListNode res = new ListNode();
            ListNode curr = res;
            // å‡ä¸ä¸º ç©º çš„æƒ…å†µ
            while (list1 != null && list2 != null) {
                if (list1.val <= list2.val) {
                    curr.next = list1;
                    list1 = list1.next;
                } else {
                    curr.next = list2;
                    list2 = list2.next;
                }
                curr = curr.next;
            }
            // è‡³å°‘æœ‰ä¸€ä¸ªä¸º ç©º çš„æƒ…å†µ
            curr.next = list1 == null ? list2 : list1;
            return res.next;
        }
    }
```



### æ–¹æ³•äºŒï¼šé€’å½’

```java
    /**
     * 2ã€é€’å½’ -- 0ms(100.00%), 41.62MB(5.14%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(m + n), å…¶ä¸­ m å’Œ n åˆ†åˆ«ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(m + n)
     */
    class Solution2 {
        public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
            if (list1 == null) {
                return list2;
            } else if (list2 == null) {
                return list1;
            } else if (list1.val < list2.val) {
                list1.next = mergeTwoLists(list1.next, list2);
                return list1;
            } else {
                list2.next = mergeTwoLists(list1, list2.next);
                return list2;
            }
        }
    }
```

> å…ˆé€’å½’ï¼Œå†å›æº¯ return



## [70. çˆ¬æ¥¼æ¢¯](https://leetcode.cn/problems/climbing-stairs/)

![image](https://cmty256.github.io/imgs-blog/basics/image.52wzs04fbm40.webp)

```java
// åŠ¨æ€è§„åˆ’
class Solution {
    public int climbStairs(int n) {
        // 001 011 112 123 235
        int a = 0, b = 0, res = 1;

        for(int i =1; i <= n; i++) {
            a = b;
            b = res;
            res = a + b;
        }
        return res;
    }
}
```

## [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› *å®ƒçš„ **ä¸­åº** éå†* ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,3,2]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`

 

**è¿›é˜¶:** é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ



### æ–¹æ³•ä¸€ï¼šé€’å½’

```java
    /**
     * 1ã€é€’å½’ -- 0ms(100.00%), 40.80MB(5.08%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            // æ–°å»ºä¸€ä¸ªå­˜æ”¾éå†ç»“æœçš„é›†åˆ
            List<Integer> res = new ArrayList<>();
            // å·¦æ ¹å³æ’åº éå†
            midorder(root, res);

            // è¿”å›éå†ç»“æœ
            return res;
        }

        public void midorder(TreeNode root, List<Integer> res) {
            // åˆ¤æ–­åˆ°ç©ºèŠ‚ç‚¹ï¼Œç›´æ¥æ–­å¼€
            if (root == null) {
                return;
            }
            // é€’å½’å·¦å­æ ‘
            midorder(root.left, res);
            // å­˜å€¼
            res.add(root.val);
            // é€’å½’å³å­æ ‘
            midorder(root.right, res);
        }
    }
```



### æ–¹æ³•äºŒï¼šæ ˆ

```java
    /**
     * 2ã€æ ˆ -- 0ms(100.00%), 40.73MB(5.29%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            // åˆ›å»ºç»“æœåˆ—è¡¨ï¼Œç”¨äºå­˜å‚¨ä¸­åºéå†åçš„å€¼
            List<Integer> res = new ArrayList<>();
            // åˆ›å»ºä¸€ä¸ªæ ˆï¼Œç”¨äºå­˜å‚¨éå†è¿‡ç¨‹ä¸­çš„èŠ‚ç‚¹
            Stack<TreeNode> stack = new Stack<>();

            // å½“æ ¹èŠ‚ç‚¹ä¸ä¸ºç©ºæˆ–è€…æ ˆä¸ä¸ºç©ºæ—¶ï¼Œå¾ªç¯ç»§ç»­
            while (root != null || !stack.isEmpty()) {
                // å¦‚æœæ ¹èŠ‚ç‚¹ä¸ä¸ºç©º
                if (root != null) {
                    // å°†æ ¹èŠ‚ç‚¹å…¥æ ˆ
                    stack.push(root);
                    // ç»§ç»­éå†å·¦å­æ ‘
                    root = root.left;
                    // å¦åˆ™ï¼Œå¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹ï¼Œå°†å…¶å€¼æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œéå†å³å­æ ‘
                } else {
                    // å¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹
                    root = stack.pop();
                    // å°†æ ˆé¡¶èŠ‚ç‚¹çš„å€¼æ·»åŠ åˆ°åˆ—è¡¨ä¸­
                    res.add(root.val);
                    // éå†å³å­æ ‘
                    root = root.right;
                }
            }

            // è¿”å›ä¸­åºéå†åçš„åˆ—è¡¨
            return res;
        }
    }
```



### æ–¹æ³•ä¸‰ï¼šè«é‡Œæ–¯éå†

```java
    /**
     * 3ã€Morris(è«é‡Œæ–¯) å®ç°ä¸­åºéå† -- 0ms(100.00%), 40.73MB(5.29%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            // åˆ›å»ºç»“æœåˆ—è¡¨ï¼Œå­˜æ”¾ä¸­åºéå†çš„ç»“æœ
            List<Integer> res = new ArrayList<>();

            // æœ‰æ ¹èŠ‚ç‚¹æ—¶ï¼Œè¿›è¡Œå¾ªç¯
            while (root != null) {
                // å¦‚æœæ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸ºç©ºï¼Œå°†æ ¹èŠ‚ç‚¹çš„å€¼æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œç„¶åå°†å³å­èŠ‚ç‚¹ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹
                if (root.left == null) {
                    res.add(root.val);
                    root = root.right;
                } else {
                    // å¦åˆ™ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹å·¦å­æ ‘çš„æœ€å³å­èŠ‚ç‚¹ï¼ˆä¸­åºéå†åœ¨æ ¹èŠ‚ç‚¹ä¹‹å‰çš„èŠ‚ç‚¹ï¼‰
                    TreeNode prev = root.left;
                    while (prev.right != null && prev.right != root) {
                        prev = prev.right;
                    }

                    // å¦‚æœæœ€å³å­èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºç©ºï¼Œå°†å…¶å³å­èŠ‚ç‚¹è®¾ç½®ä¸ºå½“å‰æ ¹èŠ‚ç‚¹ï¼Œç„¶åå°†å·¦å­èŠ‚ç‚¹ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹
                    if (prev.right == null) {
                        prev.right = root;
                        root = root.left;
                    } else {
                        // å¦åˆ™ï¼ˆå³æœ€å³å­èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºå½“å‰æ ¹èŠ‚ç‚¹ï¼‰ï¼Œå°†æ ¹èŠ‚ç‚¹çš„å€¼æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œå°†æœ€å³å­èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹è®¾ä¸ºç©ºï¼Œç„¶åå°†å³å­èŠ‚ç‚¹ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹
                        res.add(root.val);
                        prev.right = null;
                        root = root.right;
                    }
                }
            }

            // è¿”å›ä¸­åºéå†çš„ç»“æœ
            return res;
        }
    }
```



### å›¾è§£è«é‡Œæ–¯

**å‚è€ƒæ–‡ç« ï¼š**[ã€åŠ¨ç”»æ¨¡æ‹Ÿã€‘äºŒå‰æ ‘ç¥çº§éå†ï¼ï¼ˆMorrisï¼‰ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/384818393)



## [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
è¾“å‡ºï¼štrue
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
è¾“å‡ºï¼šfalse
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 1000]` å†…
- `-100 <= Node.val <= 100`

 

**è¿›é˜¶ï¼š**ä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ



### æ–¹æ³•ä¸€ï¼šè¿­ä»£ï¼ˆé˜Ÿåˆ—ï¼‰

```java
    /**
     * 1ã€è¿­ä»£ï¼ˆé˜Ÿåˆ—ï¼‰ -- 1ms(19.18%), 40.98MB(5.02%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            if(root == null) {
                return true;
            }
            Queue<TreeNode> queue1 = new LinkedList<>();
            Queue<TreeNode> queue2 = new LinkedList<>();
            queue1.offer(root.left);
            queue2.offer(root.right);

            while (!queue1.isEmpty() && !queue2.isEmpty()) {
                TreeNode left = queue1.poll();
                TreeNode right = queue2.poll();

                if(left == null && right == null){
                    continue;
                }
                if(left == null || right == null || left.val != right.val){
                    return false;
                }

                queue1.offer(left.left);
                queue1.offer(left.right);
                queue2.offer(right.right);
                queue2.offer(right.left);
            }
            return queue1.isEmpty() && queue2.isEmpty();
        }
    }
```



### æ–¹æ³•äºŒï¼šé€’å½’

```java
    /**
     * 2ã€é€’å½’ -- 0ms(100.00%), 40.89MB(5.02%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n), å› ä¸ºè¦éå† n ä¸ªèŠ‚ç‚¹
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n), å› ä¸ºé€’å½’éœ€è¦æ ˆç©ºé—´, ç©ºé—´å¤æ‚åº¦æ˜¯é€’å½’çš„æ·±åº¦, ä¹Ÿå°±æ˜¯è·Ÿæ ‘é«˜åº¦æœ‰å…³
     */
    class Solution2 {
        public boolean isSymmetric(TreeNode root) {
            return dfs(root, root);
        }

        private boolean dfs(TreeNode root1, TreeNode root2) {
            if (root1 == null && root2 == null) {
                return true;
            }
            if (root1 == null || root2 == null || root1.val != root2.val) {
                return false;
            }
            return dfs(root1.left, root2.right) && dfs(root1.right, root2.left);
        }
    }
```



## [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š3
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1,null,2]
è¾“å‡ºï¼š2
```



### æ–¹æ³•ä¸€ï¼šé˜Ÿåˆ—(å¹¿åº¦ä¼˜å…ˆæœç´¢)

```java
    /**
     * 1ã€é˜Ÿåˆ—(å¹¿åº¦ä¼˜å…ˆæœç´¢) -- 1ms(22.26%), 41.79MB(5.38%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public int maxDepth(TreeNode root) {
            // åˆ¤æ–­ æ ¹èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
            if(root == null) {
                return 0;
            }
            // å»ºç«‹ä¸€ä¸ªæ–°é˜Ÿåˆ—ï¼Œå­˜æ¯ä¸€å±‚çš„èŠ‚ç‚¹
            Queue<TreeNode> queue = new LinkedList<>();
            // æ ¹èŠ‚ç‚¹è¿›é˜Ÿåˆ—
            queue.offer(root);
            // æ·±åº¦å€¼è®¡æ•°
            int res = 0;

            // å¾ªç¯ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
            while(!queue.isEmpty()) {
                // è¿™ä¸€å±‚é˜Ÿåˆ—çš„ä¸ªæ•°
                int size = queue.size();
                // éå†è¿™ä¸€å±‚æ‰€æ‰€æœ‰èŠ‚ç‚¹å¹¶ å‡ºé˜Ÿåˆ—
                while(size > 0) {
                    // å‡ºé˜Ÿ
                    TreeNode node = queue.poll();
                    // å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œè¿›é˜Ÿ
                    if(node.left != null) {
                        queue.offer(node.left);
                    }
                    // å³å­æ ‘ä¸ä¸ºç©ºï¼Œè¿›é˜Ÿ
                    if(node.right != null) {
                        queue.offer(node.right);
                    }
                    size--;
                }
                // æ·±åº¦+1
                res++;
            }

            return res;
        }
    }
```



### æ–¹æ³•äºŒï¼šé€’å½’

```java
    /**
     * 2ã€é€’å½’ -- 0ms(100.00%), 41.63MB(11.64%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public int maxDepth(TreeNode root) {
            if (root == null) {
                return 0;
            }
            int left = maxDepth(root.left);
            int right = maxDepth(root.right);
            return Math.max(left, right) + 1;
        }
    }

```



## [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ **å‡åº** æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ **é«˜åº¦å¹³è¡¡** äºŒå‰æœç´¢æ ‘ã€‚

**é«˜åº¦å¹³è¡¡** äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
è¾“å…¥ï¼šnums = [-10,-3,0,5,9]
è¾“å‡ºï¼š[0,-3,9,-10,null,5]
è§£é‡Šï¼š[0,-10,5,null,-3,null,9] ä¹Ÿå°†è¢«è§†ä¸ºæ­£ç¡®ç­”æ¡ˆï¼š
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
è¾“å…¥ï¼šnums = [1,3]
è¾“å‡ºï¼š[3,1]
è§£é‡Šï¼š[1,null,3] å’Œ [3,1] éƒ½æ˜¯é«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚
```

 

**æç¤ºï¼š**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` æŒ‰ **ä¸¥æ ¼é€’å¢** é¡ºåºæ’åˆ—



### é¢˜ç›®åˆ†æ

é¢˜æ„ï¼šæ ¹æ®å‡åºæ•°ç»„ï¼Œæ¢å¤ä¸€æ£µé«˜åº¦å¹³è¡¡çš„ BSTğŸŒ²ã€‚

åˆ†æï¼š

- **BST çš„ä¸­åºéå†æ˜¯å‡åºçš„**ï¼Œå› æ­¤æœ¬é¢˜ç­‰åŒäºæ ¹æ®ä¸­åºéå†çš„åºåˆ—æ¢å¤äºŒå‰æœç´¢æ ‘ã€‚
- å› æ­¤æˆ‘ä»¬å¯ä»¥ä»¥å‡åºåºåˆ—ä¸­çš„ä»»ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œä»¥è¯¥å…ƒç´ å·¦è¾¹çš„å‡åºåºåˆ—æ„å»ºå·¦å­æ ‘ï¼Œä»¥è¯¥å…ƒç´ å³è¾¹çš„å‡åºåºåˆ—æ„å»ºå³å­æ ‘ï¼Œè¿™æ ·å¾—åˆ°çš„æ ‘å°±æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘å•¦
- åˆå› ä¸ºæœ¬é¢˜è¦æ±‚é«˜åº¦å¹³è¡¡ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€‰æ‹©å‡åºåºåˆ—çš„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹å¥¥



### æ–¹æ³•ä¸€ï¼šäºŒåˆ† + é€’å½’

```java
    /**
     * 1ã€äºŒåˆ† + é€’å½’ -- 0ms(100.00%), 41.91MB(88.88%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(logn)
     */
    class Solution {
        public TreeNode sortedArrayToBST(int[] nums) {
            return dfs(nums, 0, nums.length - 1);
        }

        private TreeNode dfs(int[] nums, int start, int end) {
            if (start > end) {
                return null;
            }
            // ä»¥å‡åºæ•°ç»„çš„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ root
            // start + (end - start) / 2 == (start + end) >> 1
            int mid = (start + end) >> 1;
            TreeNode root = new TreeNode(nums[mid]);
            // é€’å½’çš„æ„å»º root çš„å·¦å­æ ‘ä¸å³å­æ ‘
            root.left = dfs(nums, start, mid - 1);
            root.right = dfs(nums, mid + 1, end);
            // è¿”å›æ„å»ºå¥½çš„æ ¹èŠ‚ç‚¹ root
            return root;
        }
    }
```



å­¦ä¹ å‚è€ƒï¼š

- [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solutions/313508/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee/?envType=study-plan-v2&envId=top-100-liked)
- [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ - LeetCode Wiki (doocs.github.io)](https://doocs.github.io/leetcode/lc/108/#_3)



## [121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

![image](https://cmty256.github.io/imgs-blog/basics/image.55b1ukozauo0.webp)

```java
class Solution {
    public int maxProfit(int[] prices) {
        // è®¾ç½®èµ·å§‹æœ€å°å€¼
        int minprice = Integer.MAX_VALUE;
        // æœ€å¤§åˆ©æ¶¦
        int maxprofit = 0;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < minprice) {
                minprice = prices[i];
            }else if((prices[i] - minprice) > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
```

## [136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—](https://leetcode.cn/problems/single-number/)

![image](https://cmty256.github.io/imgs-blog/basics/image.28ubf2yhvw4k.webp)

```java
class Solution {
    public int singleNumber(int[] nums) {
        /*
        æ ¹æ®å¼‚æˆ–æ€§è´¨:
        1. ä»»ä½•æ•°å’Œ 0 åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ aâŠ•0=aã€‚
        2. ä»»ä½•æ•°å’Œå…¶è‡ªèº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯ aâŠ•a=0ã€‚
        3. å¼‚æˆ–è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œå³ aâŠ•bâŠ•a=bâŠ•aâŠ•a=bâŠ•(aâŠ•a)=bâŠ•0=bã€‚        
        å› æ­¤å°†æ‰€æœ‰å…ƒç´ è¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°ç»“æœ
         */
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
}
```

å¯ä»¥åˆ©ç”¨ Hash è¡¨: 
```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count == 1) {
                return i;
            }
        }
        return -1; // can't find it.
    }
}
```
åŒå¾ªç¯ï¼š
```java
int singleNumber(int* nums, int numsSize){

    for(int i=0;i<numsSize;i++){
            
            int count=0;

        for(int j=0;j<numsSize;j++){
            
            if(nums[j]==nums[i])
                count++;
        }    
       
        if(count==1)
            return nums[i];
    }
    return -1;
}
```

## [141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)

### é¢˜ç›®æè¿°

![image-20230415112207738](https://cmty256.github.io/imgs-blog/basics/image-20230415112207738.dqek3zmxr1c.webp)

![image-20230415112225266](https://cmty256.github.io/imgs-blog/basics/image-20230415112225266.8z6bg9zgbag.webp)



### æ–¹æ³•ä¸€ï¼šå¿«æ…¢æŒ‡é’ˆ

```java
    /**
     * 1ã€å¿«æ…¢æŒ‡é’ˆ -- 0ms(100.00%), 42.80MB(21.80%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    public class Solution {
        public boolean hasCycle(ListNode head) {
            if (head == null || head.next == null) {
                return false;
            }
            ListNode fast = head.next;
            ListNode slow = head;
            while(fast != null && fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
                if (fast == slow) return true;
            }
            return false;
        }
    }
```



### æ–¹æ³•äºŒï¼šå“ˆå¸Œè¡¨

```java
    /**
     * 2ã€åˆ©ç”¨ä¸é‡å¤æ€§ï¼ˆHashSetï¼‰ -- 4ms(13.84%), 43.90MB(5.03%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    public class Solution2 {
        public boolean hasCycle(ListNode head) {
            // åˆ›å»ºä¸€ä¸ªHashSetï¼Œç”¨äºå­˜å‚¨å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹
            Set<ListNode> seen = new HashSet<ListNode>();
            while(head != null) {
                // å¦‚æœHashSetä¸­å·²ç»å­˜åœ¨å½“å‰èŠ‚ç‚¹ï¼Œåˆ™è¯´æ˜æœ‰ç¯
                if(!seen.add(head)){
                    return true;
                }
                head = head.next;
            }
            return false;
        }
    }
```



## [160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### é¢˜ç›®æè¿°

![image-20230415112714727](https://cmty256.github.io/imgs-blog/basics/image-20230415112714727.2ee7636941xc.webp)

![image-20230415113006835](https://cmty256.github.io/imgs-blog/basics/image-20230415113006835.4xnjrn3n7ps0.webp)



### æ–¹æ³•ä¸€ï¼šéå† + HashSet

```java
    /**
     * 1ã€éå† + HashSet -- 6ms(13.58%), 46.7MB(5.00%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(m + n), å…¶ä¸­ m å’Œ n åˆ†åˆ«æ˜¯ headA å’Œ headB çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(m), HashSet å­˜å‚¨çš„æ˜¯ headA çš„æ‰€æœ‰èŠ‚ç‚¹
     */
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            Set<ListNode> hashSet = new HashSet<>();
            // å…ˆéå†Aé“¾è¡¨,å¹¶æŠŠAé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹åŠ å…¥åˆ°å“ˆå¸Œé›†åˆä¸­
            ListNode temp = headA;
            while (temp != null) {
                hashSet.add(temp);
                temp = temp.next;
            }
            // å†éå†Bé“¾è¡¨
            temp = headB;
            while (temp != null) {
                // åˆ¤æ–­é›†åˆä¸­æ˜¯å¦åŒ…å«Bé“¾è¡¨çš„æ­¤èŠ‚ç‚¹
                if (hashSet.contains(temp)) {
                    // åŒ…å«ï¼Œè¿”å›ç›¸äº¤èŠ‚ç‚¹
                    return temp;
                }
                // ä¸åŒ…å«ï¼Œéå†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                temp = temp.next;
            }
            // æ²¡æœ‰ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å›null
            return null;
        }
    }
```



### æ–¹æ³•äºŒï¼šåŒæŒ‡é’ˆ

*æ€è·¯åˆ†æï¼š*

pAéå† a+c+b æ¬¡
pBéå† b+c+a æ¬¡

pA == pB
å³å¯å¾—åˆ°ç›¸äº¤èŠ‚ç‚¹

```java
    /**
     * 2ã€åŒæŒ‡é’ˆ -- 1ms(99.09%), 47.42MB(5.00%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(m + n), å…¶ä¸­ m å’Œ n åˆ†åˆ«æ˜¯ headA å’Œ headB çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            ListNode a = headA, b = headB;
            while (a != b) {
                a = a == null ? headB : a.next;
                b = b == null ? headA : b.next;
            }
            return a;
        }
    }
```



## [169. å¤šæ•°å…ƒç´ ](https://leetcode.cn/problems/majority-element/)

![image-20230415113006835](https://cmty256.github.io/imgs-blog/basics/image-20230415113006835.4xnjrn3n7ps0.webp)

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count > nums.length/2) {
                return i;
            }
        }
        return -1;
    }
}
```

## [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

### é¢˜ç›®æè¿°

![image-20230415113207929](https://cmty256.github.io/imgs-blog/basics/image-20230415113207929.75oswfayq040.webp)



### æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆ

```java
    /**
     * 1ã€è¿­ä»£ï¼ˆåŒæŒ‡é’ˆï¼‰ -- 0ms(100.00%), 41.18MB(5.01%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n), å…¶ä¸­ n ä¸ºé“¾è¡¨çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    class Solution {
        public ListNode reverseList(ListNode head) {
            // å‡è®¾æœ€å‰é¢æ˜¯ä¸ªnull
            ListNode prev = null;
            // å½“å‰èŠ‚ç‚¹ï¼Œåˆå§‹å€¼ä¸ºå¤´èŠ‚ç‚¹ã€‚
            ListNode curr = head;

            // éå†é“¾è¡¨ï¼Œæ¯éå†ä¸€æ¬¡å°±è½¬æ¢ä¸€æ¬¡ç®­å¤´
            while (curr != null) {
                // å­˜å‚¨å½“å‰èŠ‚ç‚¹ï¼ˆå¤´èŠ‚ç‚¹ï¼‰çš„ä¸‹ä¸€èŠ‚ç‚¹
                ListNode next = curr.next;
                // nullï¼ˆprevï¼‰->curr å˜ä¸º nullï¼ˆprevï¼‰<-currï¼Œè½¬æ¢ç®­å¤´
                curr.next = prev;
                // å‰ç½®æŒ‡é’ˆåç§»ä¸€ä½
                prev = curr;
                // åç½®æŒ‡é’ˆåç§»ä¸€ä½
                curr = next;
            }
            return prev;
        }
    }
```



### æ–¹æ³•äºŒï¼šé€’å½’

```java
    /**
     * 2ã€é€’å½’ -- 0ms(100.00%), 41.30MB(5.01%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n), å…¶ä¸­ n ä¸ºé“¾è¡¨çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution2 {
        public ListNode reverseList(ListNode head) {
            // ç©ºé“¾è¡¨ æˆ–è€… å°¾ç»“ç‚¹
            if(head == null || head.next == null) {
                return head;
            }
            // é€’å½’
            ListNode res = reverseList(head.next);
            // åè½¬ç®­å¤´
            head.next.next = head;
            // æ¯ä¸€èŠ‚ç‚¹æŒ‡å‘nullï¼ŒæŠŠnullæ”¾æœ€å
            head.next = null;

            return res;
        }
    }
```



## [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
è¾“å‡ºï¼š[4,7,2,9,6,3,1]
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
è¾“å…¥ï¼šroot = [2,1,3]
è¾“å‡ºï¼š[2,3,1]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´åœ¨ `[0, 100]` å†…
- `-100 <= Node.val <= 100`



### æ–¹æ³•ä¸€ï¼šé€’å½’

```java
    /**
     * 1ã€é€’å½’ï¼ˆDFSï¼‰ -- 0ms(100.00%), 40.19MB(5.04%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public TreeNode invertTree(TreeNode root) {
            if (root == null) {
                return null;
            }

            // é€’å½’å·¦å­æ ‘
            TreeNode left = invertTree(root.left);
            // é€’å½’å³å­æ ‘
            TreeNode right = invertTree(root.right);

            // ç¿»è½¬
            root.left = right;
            root.right = left;
            return root;
        }
    }
```



### æ–¹æ³•äºŒï¼šé˜Ÿåˆ—

**å±‚åºéå†**

```java
    /**
     * 2ã€é˜Ÿåˆ—ï¼ˆBFSï¼‰ -- 0ms(100.00%), 40.00MB(17.56%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution2 {
        public TreeNode invertTree(TreeNode root) {
            if (root == null) {
                return null;
            }
            // Queue<TreeNode> queue = new LinkedList<>();
            Queue<TreeNode> queue = new ArrayDeque<>();
            queue.offer(root);

            while (!queue.isEmpty()) {
                TreeNode cur = queue.poll();

                TreeNode temp = cur.left;
                cur.left = cur.right;
                cur.right = temp;

                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }

            return root;
        }
    }
```



### æ–¹æ³•ä¸‰ï¼šæ ˆ

```java
    /**
     * 3ã€æ ˆï¼ˆDFSï¼‰ -- 0ms(100.00%), 40.21MB(5.04%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution3 {
        public TreeNode invertTree(TreeNode root) {
            if (root == null) {
                return null;
            }
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);

            while (!stack.isEmpty()) {
                TreeNode cur = stack.pop();
              
                TreeNode tmp = cur.left;
                cur.left = cur.right;
                cur.right = tmp;

                if (cur.left != null) {
                    stack.push(cur.left);
                }
                if (cur.right != null) {
                    stack.push(cur.right);
                }
            }

            return root;
        }
    }
```


## [234. å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/)

### é¢˜ç›®æè¿°

![image-20230415113739219](https://cmty256.github.io/imgs-blog/basics/image-20230415113739219.1nzx898nikgw.webp)



### æ–¹æ³•ä¸€ï¼šéå† + æ•°ç»„

```java
    /**
     * 1ã€éå† + æ•°ç»„ -- 4ms(79.41%), 55.22MB(84.99%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public boolean isPalindrome(ListNode head) {
            // ç©ºé“¾è¡¨æˆ–ä»…åŒ…å«ä¸€ä¸ªå…ƒç´ çš„é“¾è¡¨æ— è®ºå¦‚ä½•éƒ½æ˜¯å›æ–‡çš„ï¼ˆé¢˜ç›®æè¿°å¿…å®šä¸ä¸ºç©ºï¼‰
            // if (head == null || head.next == null) {
            //     return true;
            // }
            int len = 0;
            ListNode p = head;
            // å¾—å‡ºé“¾è¡¨é•¿åº¦
            while (p != null) {
                len++;
                p = p.next;
            }
            // å®šä¹‰ä¸€ä¸ªä¸é“¾è¡¨ä¸€æ ·é•¿çš„æ•°ç»„
            int[] arr = new int[len];
            // é‡æ–°å®šä¹‰ä¸€ä¸‹é“¾è¡¨ï¼Œå› ä¸ºä¸Šé¢å®šä¹‰çš„å·²ç»ä¸ºç©º
            p = head;
            for (int i = 0; i < len; i++) {
                arr[i] = p.val;
                p = p.next;
            }
            for (int i = 0; i < len / 2; i++) {
                if (arr[i] != arr[len - 1 - i]) {
                    return false;
                }
            }
            return true;
        }
    }
```



### æ–¹æ³•äºŒï¼šéå† + åˆ—è¡¨

```java
    /**
     * 2ã€éå† + åˆ—è¡¨ -- 8ms(37.68%), 54.37MB(97.42%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        public boolean isPalindrome(ListNode head) {
            List<Integer> list = new ArrayList<>();
            while (head != null) {
                list.add(head.val);
                head = head.next;
            }
            int mid = list.size() >> 1;
            for (int left = 0; left < mid; left++) {
                if (list.get(left) != list.get(list.size() - 1 - left)) {
                    return false;
                }
            }
            return true;
        }
    }
```



### æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆ + åè½¬é“¾è¡¨

```java
    /**
     * 3ã€å¿«æ…¢æŒ‡é’ˆ + åè½¬é“¾è¡¨ -- 4ms(79.41%), 67.43MB(5.6%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(1)
     */
    class Solution {
        public boolean isPalindrome(ListNode head) {
            if (head == null || head.next == null) {
                return true;
            }

            // ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹
            ListNode slow = head;
            ListNode fast = head;
            while (fast.next != null && fast.next.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            // åè½¬é“¾è¡¨çš„ååŠéƒ¨åˆ†
            ListNode secondHalf = reverseList(slow.next);
            slow.next = null;

            // æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†
            ListNode p1 = head;
            ListNode p2 = secondHalf;
            while (p1 != null && p2 != null) {
                if (p1.val != p2.val) {
                    return false;
                }
                p1 = p1.next;
                p2 = p2.next;
            }

            return true;
        }

        private ListNode reverseList(ListNode head) {
            ListNode prev = null;
            ListNode current = head;
            while (current != null) {
                ListNode nextNode = current.next;
                current.next = prev;
                prev = current;
                current = nextNode;
            }
            return prev;
        }
    }
```



## [283. ç§»åŠ¨é›¶](https://leetcode.cn/problems/move-zeroes/)

### é¢˜ç›®æè¿°

![image-20230415113922714](https://cmty256.github.io/imgs-blog/basics/image-20230415113922714.24hgpey01ctc.webp)



### æ–¹æ³•ä¸€ï¼šä½ç½®äº¤æ¢

```java
    /**
     * 1ã€ä½ç½®äº¤æ¢ -- 1ms(99.96%), 44.23MB(16.49%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦åˆ†æï¼šç”±äºåªå¯¹æ•°ç»„è¿›è¡Œäº†ä¸€æ¬¡éå†ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
     * <p>
     * ç©ºé—´å¤æ‚åº¦åˆ†æï¼šé™¤äº†è¾“å…¥æ•°ç»„ä¹‹å¤–ï¼Œæ²¡æœ‰ä½¿ç”¨é¢å¤–çš„æ•°æ®ç»“æ„æ¥å­˜å‚¨ä¿¡æ¯ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚
     */
    class Solution {
        public void moveZeroes(int[] nums) {
            // jç”¨æ¥è®°å½•é0å…ƒç´ çš„ç´¢å¼•
            int j = 0;
            // éå†æ•°ç»„
            for (int i = 0; i < nums.length; i++) {
                // å¦‚æœå½“å‰å…ƒç´ ä¸ä¸º0
                if (nums[i] != 0) {
                    // è®°å½•å½“å‰å…ƒç´ 
                    int tmp = nums[j];
                    // å°†å½“å‰å…ƒç´ èµ‹å€¼ç»™é0å…ƒç´ çš„ç´¢å¼•
                    nums[j] = nums[i];
                    // å°†è®°å½•çš„å½“å‰å…ƒç´ èµ‹å€¼ç»™å½“å‰å…ƒç´ 
                    nums[i] = tmp;
                    // é0å…ƒç´ çš„ç´¢å¼•åŠ 1
                    j++;
                }
            }
        }
    }
```



### æ–¹æ³•äºŒï¼šæ–°æ•°ç»„æ‹·è´åˆ°åŸæ•°ç»„

```java
    /**
     * 2ã€æ–°æ•°ç»„æ‹·è´åˆ°åŸæ•°ç»„ -- 1ms(99.96%), 43.45MB(98.82%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šæ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºä¸¤ä¸ªå¾ªç¯çš„æ—¶é—´å¤æ‚åº¦ä¹‹å’Œï¼Œå³ O(n + n) = O(2n)ã€‚
     * ç©ºé—´å¤æ‚åº¦ä¸ºï¼šç”±äºåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„æ•°ç»„ arr æ¥å­˜å‚¨éé›¶å…ƒç´ ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä¸º O(n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
     */
    class Solution {
        public void moveZeroes(int[] nums) {

            int[] arr = new int[nums.length];
            int count = 0;
            // éå†æ•°ç»„numsï¼Œå°†é0å…ƒç´ æ”¾å…¥æ–°çš„æ•°ç»„arrä¸­
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] != 0) {
                    arr[count] = nums[i];
                    count++;
                }
            }
            // å°†æ–°æ•°ç»„arrä¸­çš„å‰©ä½™ä½ç½®éƒ½èµ‹å€¼ä¸º0
            for (int j = count; j < nums.length; j++) {
                arr[j] = 0;
            }
            // å°†æ–°æ•°ç»„arrçš„å€¼æ‹·è´åˆ°åŸæ•°ç»„numsä¸­
            // nums = Arrays.copyof(arr,arr.length);
            System.arraycopy(arr, 0, nums, 0, arr.length);
        }
    }
```



## [338. æ¯”ç‰¹ä½è®¡æ•°](https://leetcode.cn/problems/counting-bits/)

![image-20230415114023587](https://cmty256.github.io/imgs-blog/basics/image-20230415114023587.6a679w3d6cs0.webp)

æœ€é«˜æœ‰æ•ˆä½ï¼š

```java
class Solution {
    public int[] countBits(int n) {
        int[] bits = new int[n + 1];
        // æœ€é«˜æœ‰æ•ˆä½
        int highBit = 0;
        for(int i = 1; i <= n; i++) {
            // åˆ¤æ–­ iæ˜¯å¦æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œå¦‚æœæ•°å­—iæ˜¯2çš„å¹‚æ¬¡æ–¹(10,100)ï¼Œåˆ™å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åªæœ‰æœ€é«˜ä½æ˜¯1ï¼Œå…¶ä½™ä½éƒ½æ˜¯0
            if((i & (i - 1)) == 0) {
                // å¦‚æœæ˜¯ï¼Œæ›´æ–°å½“å‰æœ€é«˜ä½ï¼ˆå®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åªæœ‰æœ€é«˜ä½æ˜¯1ï¼Œå…¶ä½™ä½éƒ½æ˜¯0ï¼‰
                highBit = i;
            }
            // å¦‚æœå½“å‰æ•°å­—iæ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œé‚£ä¹ˆå®ƒçš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ä¸º1ï¼›ï¼ˆæ­¤æ—¶æœ€é«˜ä½æ˜¯è‡ªå·±ï¼Œbits[0] + 1ï¼‰
            // å¦åˆ™ï¼Œå®ƒçš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ç­‰äºå®ƒå»æ‰æœ€é«˜ä½1(110 -> 10)åçš„æ•°å­—çš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°åŠ 1
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
}
```

> (i & (i - 1)) == 0æ˜¯ä¸€ä¸ªä½è¿ç®—çš„åˆ¤æ–­æ¡ä»¶ï¼Œå®ƒçš„å«ä¹‰æ˜¯ï¼šå¦‚æœæ•°å­—iæ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œåˆ™å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åªæœ‰æœ€é«˜ä½æ˜¯1ï¼Œå…¶ä½™ä½éƒ½æ˜¯0ã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬å°†iä¸i-1è¿›è¡ŒæŒ‰ä½ä¸è¿ç®—æ—¶ï¼Œå¦‚æœç»“æœä¸º0ï¼Œåˆ™è¯´æ˜içš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åªæœ‰ä¸€ä¸ª1ï¼Œå³iæ˜¯2çš„å¹‚æ¬¡æ–¹ã€‚è¿™æ˜¯å› ä¸ºï¼Œå½“iæ˜¯2çš„å¹‚æ¬¡æ–¹æ—¶ï¼Œi-1çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æ‰€æœ‰ä½éƒ½æ˜¯1ï¼Œå› æ­¤æŒ‰ä½ä¸è¿ç®—ä¹‹åå¾—åˆ°çš„ç»“æœä¸º0ï¼›è€Œå½“iä¸æ˜¯2çš„å¹‚æ¬¡æ–¹æ—¶ï¼Œi-1çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ä¼šæœ‰ä¸€äº›ä½æ˜¯0ï¼ŒæŒ‰ä½ä¸è¿ç®—ä¹‹åå¾—åˆ°çš„ç»“æœå°±ä¸ä¸º0ã€‚
> åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªæ¡ä»¶æ¥åˆ¤æ–­å½“å‰æ•°å­—iæ˜¯å¦æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ›´æ–°å½“å‰çš„æœ€é«˜ä½ä¸ºè¯¥æ•°å­—ï¼›å¦åˆ™ï¼Œæ ¹æ®ä¸Šè¿°ç®—æ³•è®¡ç®—å½“å‰æ•°å­—çš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚å› æ­¤ï¼Œè¿™ä¸ªåˆ¤æ–­æ¡ä»¶åœ¨è¿™ä¸ªç®—æ³•ä¸­èµ·åˆ°äº†å¾ˆé‡è¦çš„ä½œç”¨ã€‚
>
> ```java
> class Solution {
>     public int[] countBits(int n) {
>         int[] bits = new int[n + 1];
>         for (int i = 1; i <= n; i++) {
>             bits[i] = bits[i >> 1] + (i & 1);
>         }
>         return bits;
>     }
> }
> ```
> è¿™ä¹Ÿæ˜¯ä¸€ä¸ªè®¡ç®—æ•°å­—0åˆ°nçš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°çš„ç®—æ³•ï¼Œå…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½è¿ç®—æ¥è®¡ç®—æ¯ä¸ªæ•°å­—çš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚å…·ä½“æ¥è¯´ï¼Œå¯¹äºä¸€ä¸ªæ•°å­—iï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶å³ç§»ä¸€ä½ï¼Œå¹¶å°†ç»“æœèµ‹å€¼ç»™bits[i]ï¼Œç„¶åå†åˆ¤æ–­içš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æœ€ä½ä½æ˜¯å¦ä¸º1ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å°†bits[i]åŠ 1ã€‚ä¾‹å¦‚ï¼Œå¯¹äºæ•°å­—6ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤ºä¸º110ï¼‰ï¼Œæˆ‘ä»¬å°†å…¶å³ç§»ä¸€ä½å¾—åˆ°3ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤ºä¸º11ï¼‰ï¼Œæ­¤æ—¶bits[6]çš„å€¼ä¸ºbits[3]çš„å€¼ï¼›ç„¶åæˆ‘ä»¬å†åˆ¤æ–­6çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æœ€ä½ä½æ˜¯å¦ä¸º1ï¼Œå‘ç°æ˜¯ï¼Œå› æ­¤éœ€è¦å°†bits[6]åŠ 1ï¼Œæœ€ç»ˆbits[6]çš„å€¼ä¸º2ã€‚
> è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªç®—æ³•æ¯”ä¸Šä¸€ä¸ªç®—æ³•è¦æ›´åŠ ç®€å•å’Œé«˜æ•ˆï¼Œå› ä¸ºå®ƒä¸éœ€è¦ä½¿ç”¨ç‰¹æ®Šçš„åˆ¤æ–­æ¡ä»¶ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨ä½è¿ç®—æ¥è®¡ç®—æ¯ä¸ªæ•°å­—çš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚

## [448. æ‰¾åˆ°æ‰€æœ‰æ•°ç»„ä¸­æ¶ˆå¤±çš„æ•°å­—](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

![image-20230415114217649](https://cmty256.github.io/imgs-blog/basics/image-20230415114217649.vs9ltf1lcf4.webp)

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int num : nums) {
            // è®¡ç®—å½“å‰æ•°åº”è¯¥å‡ºç°çš„ä½ç½®ï¼Œå¹¶å°†è¯¥ä½ç½®çš„æ•°åŠ ä¸Šn
            int x = (num - 1) % n;
            nums[x] += n;
        }
        List<Integer> res = new ArrayList<Integer>();
        for(int i = 0; i < n; i++) {
            // å¦‚æœæŸä¸ªä½ç½®çš„æ•°å°äºnï¼Œåˆ™è¯´æ˜è¯¥ä½ç½®å¯¹åº”çš„æ•°å­—æ²¡æœ‰å‡ºç°è¿‡
            if(nums[i] <= n) {
                res.add(i + 1);
            }
        }
        return res;
    }
}
```

## [461. æ±‰æ˜è·ç¦»](https://leetcode.cn/problems/hamming-distance/)

![image-20230415114302597](https://cmty256.github.io/imgs-blog/basics/image-20230415114302597.4xmyhzhcekg0.webp)

æœ€ä½ä½ï¼š

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while(s != 0) {
            // ç´¯ç§¯æœ€ä½ä½
            ret += s & 1;
            // å³ç§»ä¸€ä½
            s >>= 1;
        }
        return ret;
    }
}
```

Interger.bitCount()ï¼š

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```
> bitCountå®ç°çš„åŠŸèƒ½æ˜¯è®¡ç®—ä¸€ä¸ªï¼ˆbyte,short,char,intç»Ÿä¸€æŒ‰ç…§intæ–¹æ³•è®¡ç®—ï¼‰int,longç±»å‹çš„æ•°å€¼åœ¨äºŒè¿›åˆ¶ä¸‹â€œ1â€çš„æ•°é‡

## [543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree/)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¯¥æ ‘çš„ **ç›´å¾„** ã€‚

äºŒå‰æ ‘çš„ **ç›´å¾„** æ˜¯æŒ‡æ ‘ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ€é•¿è·¯å¾„çš„ **é•¿åº¦** ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç»è¿‡ä¹Ÿå¯èƒ½ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ `root` ã€‚

ä¸¤èŠ‚ç‚¹ä¹‹é—´è·¯å¾„çš„ **é•¿åº¦** ç”±å®ƒä»¬ä¹‹é—´è¾¹æ•°è¡¨ç¤ºã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
è¾“å…¥ï¼šroot = [1,2,3,4,5]
è¾“å‡ºï¼š3
è§£é‡Šï¼š3 ï¼Œå–è·¯å¾„ [4,2,1,3] æˆ– [5,2,1,3] çš„é•¿åº¦ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1,2]
è¾“å‡ºï¼š1
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 104]` å†…
- `-100 <= Node.val <= 100`



### æ–¹æ³•ä¸€ï¼šé€’å½’

```java
    /**
     * 1ã€é€’å½’ -- 0ms(100.00%), 41.93MB(5.15%)
     * <p>
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     * <p>
     * ç©ºé—´å¤æ‚åº¦ï¼šO(n)
     */
    class Solution {
        // å…¨å±€å˜é‡ï¼Œç»Ÿè®¡è·¯å¾„èŠ‚ç‚¹æ•°
        int res;

        public int diameterOfBinaryTree(TreeNode root) {
            // äºŒå‰æ ‘çš„ç›´å¾„ï¼ˆæœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ï¼‰
            res = 1;
            // è®¡ç®—å­æ ‘çš„æ·±åº¦
            depth(root);
            // èŠ‚ç‚¹æ•° - 1 ä¸ºè¾¹æ•°
            return res - 1;
        }

        // å®šä¹‰ä¸€ä¸ªæ–¹æ³• depth ç”¨æ¥æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        public int depth(TreeNode node) {
            // è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0
            if (node == null) {
                return 0;
            }
            // å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘çš„æ·±åº¦
            int L = depth(node.left);
            // å½“å‰èŠ‚ç‚¹çš„å³å­æ ‘çš„æ·±åº¦
            int R = depth(node.right);

            // æ›´æ–° ans çš„å€¼ï¼Œä»¥æ‰¾åˆ°æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°
            res = Math.max(res, L + R + 1);

            // è¿”å›å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ã€‚
            return Math.max(L, R) + 1;
        }
    }
```



## [617. åˆå¹¶äºŒå‰æ ‘](https://leetcode.cn/problems/merge-two-binary-trees/)

![image-20230415114745917](https://cmty256.github.io/imgs-blog/basics/image-20230415114745917.2iidy5q5o8q0.webp)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        // æ·±åº¦ä¼˜å…ˆæœç´¢
        TreeNode merged = new TreeNode(root1.val + root2.val);
        merged.left = mergeTrees(root1.left, root2.left);
        merged.right = mergeTrees(root1.right, root2.right);
        return merged;
    }
}
```

