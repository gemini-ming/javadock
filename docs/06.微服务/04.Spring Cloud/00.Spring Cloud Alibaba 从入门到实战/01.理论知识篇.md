---
title: 基础知识篇
date: 2023-09-18 16:34:23
permalink: /pages/75e0cf/
author: 
  name: 泪伤荡
  link: https://github.com/gemini-ming
---
# 基础知识篇

## 理论篇

俗话说，**没有最好的架构，只有最合适的架构**。

> 微服务架构也是随着信息产业的发展而出现的最有普遍适用性的一套架构模式。

通常来说，我们认为架构发展历史经历了这样一个过程：单体架构 -> SOA 面向服务架构 -> 微服务架构

### 单体架构

MVC 架构以及由此衍生出来各种多层架构如下图所示：

![image-20230918164349391](https://cmty256.github.io/imgs-blog/basics/image-20230918164349391.4etixq55nso0.webp)

*优点*

在程序规模不大，开发人员很少的时候，下面的几点是非常显著的：

1. 开发简单。单体应用的结构，天然决定了所有代码都集中在一起，开发者不需要在多个应用之间来回跳转来寻找其中的调用逻辑。
2. 测试简单。所有代码都在一个应用里，测试人员可以很方便的做到端到端的测试（当然，很多时候测试人员就是开发者自己）。
3. 部署简单。因为一个应用就是产品功能的全集，所以在部署的时候，只需要不是一款应用即可。即使是集群部署，也不会增加多少复杂度：只需要将应用部署多份即可。
4. 开发迅速。上面的各种简单，带来的就是软件功能可以快速实现。很多时候，实现需求的速度是项目成功与否的决定性因素。 

所以，在开发简单和独立的产品时，单体架构依然是第一优先选择。

*弊端*

随着功能的持续增加、团队规模的不断扩大，我们很快就会发现单体应用的弊端：

1. 应用膨胀。所有代码都在一个应用里，导致应用的代码量迅速上升，对于开发者来说，经常需要在海量的代码里找到自己需要维护的哪一行，这种体验往往是令人崩溃的。同时，对于 IDE 来说，一个应用内大量代码也会严重拖慢其运行效率。
2. 团队合作冲突。这种冲突会体现在多个方面：开发阶段，很容易由于修改相同的代码导致代码冲突。部署阶段，又会因为“运行环境里跑的是谁的分支”而造成新的冲突。所有的这些冲突将会严重影响到团队的合作效率。
3. 运行效率 & 稳定性。单体应用，由于逻辑都集中在一起，启动时需要完成所有的初始化工作；同时单一功能的问题也会因为运行在一个进程内，从而导致整个应用宕机。

### SOA 架构

SOA 是 Service-Oriented Architecture 的简写，直译为“**面向服务的架构**”。

核心思想是：将系统的功能解构为一系列服务。

> 与单体架构按照技术职责进行**水平拆分**不同，SOA 会按照业务领域对应用进行**粗粒度的垂直拆分**

*垂直拆分带来的问题*

应用从单体应用做了垂直拆分以后，就会变成一些相对独立的应用。此时，**应用间的依赖、调用等相关问题**自然而然的就会浮现出来。此时就需要下面这些技术方案来解决这些问题：

1. XML -- 一种标记语言，用于以文档格式描述消息中的数据。
2. SOAP（Simple Object Access Protocol）-- 在计算机网络上交换基于 XML 的消息的协议，通常是用 HTTP。
3. WSDL（Web Services Description Language，Web 服务描述语言）-- 基于 XML 的描述语言，用于描述与服务交互所需的服务的公共接口，协议绑定，消息格式。
4. UDDI（Universal Description, Discovery, and Integration，是统一描述、发现和集成） -- 基于 XML 的注册协议，用于发布 WSDL 并允许第三方发现这些服务。
5. ESB（Enterprise Service Bus, 企业服务总线）-- 支持异构环境中的服务、消息，以及基于事件的交互，并且具有适当的服务级别和可管理性。

*典型 SOA 架构模式图*：

![image-20230918171124589](https://cmty256.github.io/imgs-blog/basics/image-20230918171124589.62amj12p1ms0.webp)

*弊端以及不足*

1. 高门槛。ESB 本身就是一套非常复杂的系统，通过 ESB 落地 SOA ，对开发人员的要求很高。甚至还会需要厂商参与；
2. 厂商绑定。由于缺乏统一保准，不同厂商的解决方案之间很难做切换。
3. 不适应云环境。在如今的互联网时代，速度就是一切。由此诞生了敏捷开发、持续集成等在不同节点提升业务上线速度的办法。但是方向是不一致的。
4. 中心化。虽然应用本身实现了分布式与水平扩展，但是 ESB 却成了系统的中枢神经。

### 微服务架构

直接从【SOA、微服务】这两者的区别入手来理解到底什么是微服务：

|            | 传统 SOA                       | 微服务                                                       |
| ---------- | ------------------------------ | ------------------------------------------------------------ |
| 通信方式   | 基于 ESB，SOAP、W SDL 等重协议 | 点对点通信，开放式协议，如 RESTful、gR PC、或者是轻量级的二进制协议。 |
| 数据管理   | 全局数据模型以及共享存储       | 每个服务独立模型和存储                                       |
| 服务粒度   | 较粗                           | 较细                                                         |
| 诞生的背景 | 企业级应用                     | 互联网                                                       |
| 解决的问题 | 面向企业内，系统集成           | 面向最终产品，解决扩展，维护的问题                           |

通信手段、数据等的不同只是表象，其本质区别还是由于两者诞生于不同历史时期，需要解决的问题域不同。

- SOA 解决的核心问题是**复用**，
- 而微服务解决的核心问题是**扩展**。

*微服务的几个重要概念*

1. 一套小服务
2. 独立进程
3. 轻量级通信协议
4. 可独立部署
5. 多语言 & 不同储技术

*微服务架构图*

![image-20230918174849820](https://cmty256.github.io/imgs-blog/basics/image-20230918174849820.4xl6p2ydsa00.webp)

要考虑的问题（主要包括但不限于）：

1. 通过服务实现组件化
2. 根据业务组织系统
3. 做产品而不是做项目
4. 简单高效的通信协议
5. 自动化基础设施
6. 面向失败的设计
7. 具备进化能力的设计

> 今天我们所说的【微服务】是一个庞大且复杂的概念集合，它既是一种架构模式，也是实现这种架构模式时所使用的技术方案的集合。

## 框架篇

### Spring

在 Spring 框架的早期，大家都喜欢称其为【轻量化】框架，【轻量】是相对于 EJB 等企业级开发框架而言的。

其【轻】的特性体现在：

1. 框架本身的大小很小，早期版本的 jar 包不超过 1MB；
2. 同时不依赖于运行容器，也是说任何容器里都可以运行 Spring 框架；
3. 更加重要的是 Spring 是非侵入的，使用 Spring 开发的应用可以不完全依赖 Spring 的类。

### SpringBoot

使用 Spring Boot 可以大大简化 Spring 应用的开发工作。

在 Spring Boot 中无论是官方组件还是第三方框架都会提供各种【`starter`】来方便开发者进行依赖和集成。

由于采用了 “**约定大于配置**” 的思想，开发者在引入 “`stater`” 以后只需要做少量的配置工作就可以完成框架集成工作。

> 往往开发者只需要很少量的代码就可以实现以前大量配置文件才能做到的功能。

Spring 官方对 Spring Boot 特色定义如下：

1. 创建独立的 Spring 应用程序 
2. 直接嵌入 Tomcat，Jetty 或 Undertow（无需部署 WAR 文件）
3. 提供自以为是的 “`starter`” 依赖项，以简化构建配置
4. 尽可能自动配置 Spring 和三方类库
5. 提供可用于生产的功能，例如指标，运行状况检查和外部化配置
6. 完全没有代码生成，也不需要 XML 配置

### Spring Cloud

“分布式系统中的常见模式” 给了 Spring Cloud 一个清晰的定位，即“模式”。也就是说 Spring Cloud 是针对分布式系统开发所做的通用抽象，是标准模式的实现。

Spring 官方给出的一个 Height Light 的架构图：

![image-20230918180448462](https://cmty256.github.io/imgs-blog/basics/image-20230918180448462.6ovu8naeg8s0.webp)

> 结论：Spring Cloud 是以微服务为核心的分布式系统的一个构建标准。

### Spring Cloud Alibaba

既然说 Spring Cloud 是标准，那么自然少不了针对标准的实现。

参与这个标准的实现有很多，比如：

1. Google 的 Spring Cloud GCP
2. Netflix 的 Spring Cloud Netflix
3. Microsoft 的 Spring Cloud Azure 
4. 阿里巴巴的 Spring Cloud Alibaba

*介绍图*

![image-20230918180717293](https://cmty256.github.io/imgs-blog/basics/image-20230918180717293.5eca0ci9nds0.webp)

图中深色的部分，其实它就是 Spring Cloud 标准，一共有 3 层。

1. 中间颜色最深的部分就是及整个微服务最核心的内容，包括了 “RPC 调用” 以及 “服务注册与发现”。
2. 第二层，也就是围绕着核心的这一圈，是一些辅助微服务更好的工作功能，包括了负载均衡、路由、网关、断路器，还有就是追踪等等这些内容。
3. 再外层的话，主要是些分布式云环境里的通用能力。

最外面这一圈，是 Spring Cloud Alibaba 对 Spring Cloud 的实现。

- 右上部分是 对于 Spring Cloud 标准的实现。例如，我们通过 Dubbo 实现了 RPC 调用功能，通过 Nacos 实现了“服务注册与发现”、“分布式配置”，通过 Sentinel 实现了断路器等等。
- 左下部分是我们 Spring Cloud Alibaba 对阿里云**各种服务的集成**。

*为什么要加上【集成】这一部分呢？*

因为在实际生产过程中，单独使用微服务框架其实并不足以支撑我们去构建一个完整的系统。所以这部分是用阿里帮助开发者完成微服务以外的云产品集成的功能。

*包含组件*

目前，Spring Cloud Alibaba 包含如下组件：

**开源部分**

1. Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
2. Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
3. RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。
4. Dubbo：Apache Dubbo 是一款高性能 Java RPC 框架。
5. Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。

**平台服务部分**

1. Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
2. Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。
3. Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力， 帮助企业迅速搭建客户触达通道。

## 工具篇

### Java 工程脚手架

访问地址：[云原生应用脚手架](https://start.aliyun.com/bootstrap.html)

### Sandbox 沙箱环境

Sandbox 沙箱环境，为开发者带来一套快速上手、免除任何环境依赖、免费、便捷的 开发&运行环境。允许开发者在上面查看、修改、部署示例代码，并且由平台提供相关运行资源。

## 参考书籍

[重磅下载 | Java 开发者必备手册《Spring Cloud Alibaba 从入门到实战》，阿里双11同款！-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/778252)

